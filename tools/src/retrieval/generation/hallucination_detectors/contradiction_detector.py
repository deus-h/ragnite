"""
Contradiction Detector

This module defines the ContradictionDetector that identifies internal contradictions
within language model generated text.
"""

import re
import itertools
from typing import Any, Dict, List, Optional, Union, Tuple, Set, Callable
from .base_hallucination_detector import BaseHallucinationDetector, HallucinationDetectionResult


class ContradictionDetector(BaseHallucinationDetector):
    """
    Detector for identifying internal contradictions in generated text.
    
    This detector analyzes generated text to identify statements that contradict
    each other, indicating potential hallucinations or inconsistencies.
    
    Attributes:
        method (str): Method used for contradiction detection ("nli", "llm", "rule").
        nli_model: Model for natural language inference.
        llm_provider (Callable): Function for LLM-based contradiction detection.
        contradiction_rules (List[Dict]): List of rule-based contradiction patterns.
        threshold (float): Threshold for considering statements contradictory.
        max_distance (int): Maximum distance between statements to check for contradictions.
    """
    
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the contradiction detector.
        
        Args:
            config: Configuration dictionary that may include:
                - method: Detection method ("nli", "llm", "rule") (default: "rule")
                - nli_model: Model for natural language inference
                - llm_provider: Function for LLM-based contradiction detection
                - contradiction_rules: List of rule-based contradiction patterns
                - threshold: Threshold for considering statements contradictory (default: 0.7)
                - max_distance: Maximum number of statements between potentially contradicting ones (default: 10)
        """
        super().__init__(config)
        self.method = self.config.get("method", "rule")
        self.nli_model = self.config.get("nli_model")
        self.llm_provider = self.config.get("llm_provider")
        self.contradiction_rules = self.config.get("contradiction_rules", [])
        self.threshold = self.config.get("threshold", 0.7)
        self.max_distance = self.config.get("max_distance", 10)
        
        # Initialize the appropriate method
        if self.method == "nli" and not self.nli_model:
            # If no NLI model provided, fall back to rule-based
            self.method = "rule"
            
        if self.method == "llm" and not self.llm_provider:
            # If no LLM provider, fall back to rule-based
            self.method = "rule"
            
        if self.method == "rule" and not self.contradiction_rules:
            # If no contradiction rules provided, use default rules
            self.contradiction_rules = self._get_default_contradiction_rules()
    
    def detect(self, 
               generated_text: str, 
               source_documents: Optional[List[Dict[str, Any]]] = None, 
               **kwargs) -> Dict[str, Any]:
        """
        Detect internal contradictions in the generated text.
        
        Args:
            generated_text: The text generated by the language model.
            source_documents: Optional list of source documents (not used for contradiction detection).
            **kwargs: Additional arguments:
                - extract_claims: Whether to extract specific claims for contradiction detection
                - max_pairs: Maximum number of statement pairs to check (to limit computation)
                
        Returns:
            A dictionary containing detection results.
        """
        # Extract statements from generated text
        extract_claims = kwargs.get("extract_claims", True)
        if extract_claims:
            statements = self._extract_statements(generated_text)
        else:
            # Use the entire text as a single statement (not useful for contradiction detection)
            statements = [{
                "statement": generated_text,
                "span": (0, len(generated_text))
            }]
        
        # If fewer than 2 statements, no contradictions possible
        if len(statements) < 2:
            return HallucinationDetectionResult(
                score=1.0,  # Perfect score
                detected_hallucinations=[],
                explanation="No contradictions detected (insufficient statements for analysis)",
                confidence=0.8,
                detection_type=self.get_detection_type()
            ).to_dict()
        
        # Generate pairs of statements to check for contradictions
        max_pairs = kwargs.get("max_pairs", 100)  # Limit to avoid excessive computation
        statement_pairs = []
        
        # Only check statements within max_distance of each other
        for i, statement1 in enumerate(statements):
            for j in range(i + 1, min(i + self.max_distance + 1, len(statements))):
                statement2 = statements[j]
                statement_pairs.append((statement1, statement2))
                
                if len(statement_pairs) >= max_pairs:
                    break
            
            if len(statement_pairs) >= max_pairs:
                break
        
        # Detect contradictions
        if self.method == "nli":
            contradiction_results = self._detect_with_nli(statement_pairs)
        elif self.method == "llm":
            contradiction_results = self._detect_with_llm(statement_pairs)
        elif self.method == "rule":
            contradiction_results = self._detect_with_rules(statement_pairs)
        else:
            raise ValueError(f"Unsupported contradiction detection method: {self.method}")
        
        # Process results
        detected_contradictions = []
        
        for (statement1, statement2), result in zip(statement_pairs, contradiction_results):
            if result["is_contradiction"]:
                detected_contradictions.append({
                    "statement1": {
                        "text": statement1["statement"],
                        "span": statement1["span"]
                    },
                    "statement2": {
                        "text": statement2["statement"],
                        "span": statement2["span"]
                    },
                    "reason": result["reason"],
                    "severity": result["severity"],
                    "confidence": result["confidence"]
                })
        
        # Transform contradictions into hallucination format
        detected_hallucinations = []
        
        for contradiction in detected_contradictions:
            # Add first statement
            detected_hallucinations.append({
                "text": contradiction["statement1"]["text"],
                "span": contradiction["statement1"]["span"],
                "reason": f"Contradicts: \"{contradiction['statement2']['text']}\" - {contradiction['reason']}",
                "severity": contradiction["severity"],
                "confidence": contradiction["confidence"],
                "contradiction_pair": True
            })
            
            # Add second statement if not already covered
            already_covered = False
            for h in detected_hallucinations:
                if h["span"] == contradiction["statement2"]["span"]:
                    already_covered = True
                    break
            
            if not already_covered:
                detected_hallucinations.append({
                    "text": contradiction["statement2"]["text"],
                    "span": contradiction["statement2"]["span"],
                    "reason": f"Contradicts: \"{contradiction['statement1']['text']}\" - {contradiction['reason']}",
                    "severity": contradiction["severity"],
                    "confidence": contradiction["confidence"],
                    "contradiction_pair": True
                })
        
        # Calculate the overall score based on the number and severity of contradictions
        if not detected_hallucinations:
            score = 1.0  # Perfect score
            confidence = 0.8
            explanation = "No internal contradictions detected in the generated text."
        else:
            # Start with perfect score and reduce based on contradictions
            score = 1.0
            
            # Each contradiction reduces the score based on severity
            for h in detected_hallucinations:
                if h.get("contradiction_pair"):  # Only count unique contradictions once
                    severity_factor = {
                        "low": 0.95,
                        "medium": 0.85,
                        "high": 0.7
                    }.get(h["severity"], 0.9)
                    score *= severity_factor
            
            # Ensure score is in [0, 1] range
            score = max(0.0, min(1.0, score))
            
            # Calculate confidence as average of individual contradiction confidences
            confidence = sum(h["confidence"] for h in detected_hallucinations) / len(detected_hallucinations)
            
            # Generate explanation
            explanation = self._generate_explanation(detected_hallucinations)
        
        # Create result object
        result = HallucinationDetectionResult(
            score=score,
            detected_hallucinations=detected_hallucinations,
            explanation=explanation,
            confidence=confidence,
            detection_type=self.get_detection_type()
        )
        
        return result.to_dict()
    
    def get_detection_type(self) -> str:
        """
        Get the type of hallucination detection performed.
        
        Returns:
            The string "contradiction"
        """
        return "contradiction"
    
    def _extract_statements(self, text: str) -> List[Dict[str, Any]]:
        """
        Extract individual statements from the generated text for contradiction detection.
        
        Args:
            text: The generated text to analyze
            
        Returns:
            List of dictionaries with statement text and character spans
        """
        statements = []
        
        # Simple sentence splitting using regex
        # In a production system, use a more robust sentence tokenizer
        sentence_pattern = r'(?<!\w\.\w.)(?<![A-Z][a-z]\.)(?<=\.|\?|\!)\s'
        spans = list(re.finditer(sentence_pattern, text))
        
        start_idx = 0
        for span in spans:
            end_idx = span.start() + 1  # Include the punctuation
            sentence = text[start_idx:end_idx].strip()
            
            if sentence:
                statements.append({
                    "statement": sentence,
                    "span": (start_idx, end_idx)
                })
            
            start_idx = span.end()
        
        # Don't forget the last sentence if it doesn't end with punctuation
        if start_idx < len(text):
            sentence = text[start_idx:].strip()
            if sentence:
                statements.append({
                    "statement": sentence,
                    "span": (start_idx, len(text))
                })
        
        return statements
    
    def _detect_with_nli(self, 
                       statement_pairs: List[Tuple[Dict[str, Any], Dict[str, Any]]]) -> List[Dict[str, Any]]:
        """
        Detect contradictions using NLI model.
        
        Args:
            statement_pairs: List of statement pairs to check for contradictions
            
        Returns:
            List of contradiction detection results
        """
        results = []
        
        # Check if we have an NLI model
        if not self.nli_model:
            # Fall back to rule-based
            return self._detect_with_rules(statement_pairs)
        
        for statement1, statement2 in statement_pairs:
            # This is a placeholder. In a real implementation, we would use the NLI model
            # to determine if the statements contradict each other
            
            # First, check for very obvious contradictions with rule-based approach
            rule_result = self._check_rule_based_contradiction(
                statement1["statement"], statement2["statement"])
            
            if rule_result["is_contradiction"]:
                # Found a contradiction with rules
                results.append(rule_result)
                continue
            
            # Run NLI model to check for contradiction
            # In a real implementation, we would run both statements through an NLI model
            # and check for contradictions
            nli_result = self._run_nli_pair(statement1["statement"], statement2["statement"])
            
            if nli_result["label"] == "contradiction" and nli_result["score"] >= self.threshold:
                # Found a contradiction
                severity = "high" if nli_result["score"] > 0.85 else "medium"
                results.append({
                    "is_contradiction": True,
                    "confidence": nli_result["score"],
                    "reason": f"NLI model detected contradiction (score: {nli_result['score']:.2f})",
                    "severity": severity
                })
            else:
                # No contradiction found
                results.append({
                    "is_contradiction": False,
                    "confidence": nli_result["score"],
                    "reason": f"No contradiction detected by NLI model",
                    "severity": "none"
                })
        
        return results
    
    def _detect_with_llm(self, 
                       statement_pairs: List[Tuple[Dict[str, Any], Dict[str, Any]]]) -> List[Dict[str, Any]]:
        """
        Detect contradictions using LLM.
        
        Args:
            statement_pairs: List of statement pairs to check for contradictions
            
        Returns:
            List of contradiction detection results
        """
        results = []
        
        # Check if we have an LLM provider
        if not self.llm_provider:
            # Fall back to rule-based
            return self._detect_with_rules(statement_pairs)
        
        for statement1, statement2 in statement_pairs:
            # First, check for very obvious contradictions with rule-based approach
            rule_result = self._check_rule_based_contradiction(
                statement1["statement"], statement2["statement"])
            
            if rule_result["is_contradiction"]:
                # Found a contradiction with rules
                results.append(rule_result)
                continue
            
            # Construct prompt for LLM
            prompt = self._construct_contradiction_prompt(
                statement1["statement"], statement2["statement"])
            
            try:
                # Get response from LLM provider
                llm_response = self.llm_provider(prompt)
                
                # Parse the response
                if "contradiction" in llm_response.lower() or "contradict" in llm_response.lower():
                    # Extract confidence if available
                    confidence = 0.8  # Default confidence
                    confidence_match = re.search(r'confidence[:\s]+([0-9.]+)', llm_response, re.IGNORECASE)
                    if confidence_match:
                        try:
                            confidence = float(confidence_match.group(1))
                            # Normalize confidence if needed
                            if confidence > 1.0:
                                confidence /= 10.0 if confidence <= 10.0 else 100.0
                        except ValueError:
                            pass
                    
                    # Extract reason if available
                    reason = "LLM detected contradiction"
                    reason_match = re.search(r'reason[:\s]+([^\n]+)', llm_response, re.IGNORECASE)
                    if reason_match:
                        reason = reason_match.group(1).strip()
                    
                    # Determine severity
                    severity = "medium"  # Default severity
                    if "definite" in llm_response.lower() or "clear" in llm_response.lower():
                        severity = "high"
                    elif "potential" in llm_response.lower() or "possible" in llm_response.lower():
                        severity = "low"
                    
                    # Found a contradiction
                    results.append({
                        "is_contradiction": True,
                        "confidence": confidence,
                        "reason": reason,
                        "severity": severity
                    })
                else:
                    # No contradiction found
                    results.append({
                        "is_contradiction": False,
                        "confidence": 0.7,
                        "reason": "No contradiction detected by LLM",
                        "severity": "none"
                    })
            except Exception as e:
                # Error in LLM detection
                results.append({
                    "is_contradiction": False,
                    "confidence": 0.5,
                    "reason": f"Error in LLM contradiction detection: {str(e)}",
                    "severity": "none"
                })
        
        return results
    
    def _detect_with_rules(self, 
                         statement_pairs: List[Tuple[Dict[str, Any], Dict[str, Any]]]) -> List[Dict[str, Any]]:
        """
        Detect contradictions using rule-based approach.
        
        Args:
            statement_pairs: List of statement pairs to check for contradictions
            
        Returns:
            List of contradiction detection results
        """
        results = []
        
        for statement1, statement2 in statement_pairs:
            result = self._check_rule_based_contradiction(
                statement1["statement"], statement2["statement"])
            results.append(result)
        
        return results
    
    def _check_rule_based_contradiction(self, statement1: str, statement2: str) -> Dict[str, Any]:
        """
        Check for contradictions between two statements using rule-based approach.
        
        Args:
            statement1: First statement
            statement2: Second statement
            
        Returns:
            Dictionary with contradiction detection result
        """
        # Normalize statements
        s1_norm = statement1.lower()
        s2_norm = statement2.lower()
        
        # Apply contradiction rules
        for rule in self.contradiction_rules:
            pattern_type = rule.get("type", "keyword")
            
            if pattern_type == "keyword":
                # Check for keyword-based contradictions
                keywords1 = rule.get("keywords1", [])
                keywords2 = rule.get("keywords2", [])
                
                # Check if statement1 contains keywords1 and statement2 contains keywords2
                if (any(kw in s1_norm for kw in keywords1) and 
                    any(kw in s2_norm for kw in keywords2)):
                    return {
                        "is_contradiction": True,
                        "confidence": rule.get("confidence", 0.7),
                        "reason": rule.get("reason", "Keyword-based contradiction detected"),
                        "severity": rule.get("severity", "medium")
                    }
                
                # Check the reverse (statement1 contains keywords2 and statement2 contains keywords1)
                if (any(kw in s1_norm for kw in keywords2) and 
                    any(kw in s2_norm for kw in keywords1)):
                    return {
                        "is_contradiction": True,
                        "confidence": rule.get("confidence", 0.7),
                        "reason": rule.get("reason", "Keyword-based contradiction detected"),
                        "severity": rule.get("severity", "medium")
                    }
            
            elif pattern_type == "regex":
                # Check for regex-based contradictions
                pattern1 = rule.get("pattern1")
                pattern2 = rule.get("pattern2")
                
                if not pattern1 or not pattern2:
                    continue
                
                # Check if statement1 matches pattern1 and statement2 matches pattern2
                if (re.search(pattern1, s1_norm) and re.search(pattern2, s2_norm)):
                    return {
                        "is_contradiction": True,
                        "confidence": rule.get("confidence", 0.7),
                        "reason": rule.get("reason", "Regex-based contradiction detected"),
                        "severity": rule.get("severity", "medium")
                    }
                
                # Check the reverse
                if (re.search(pattern1, s2_norm) and re.search(pattern2, s1_norm)):
                    return {
                        "is_contradiction": True,
                        "confidence": rule.get("confidence", 0.7),
                        "reason": rule.get("reason", "Regex-based contradiction detected"),
                        "severity": rule.get("severity", "medium")
                    }
            
            elif pattern_type == "entity":
                # Check for entity-based contradictions (same entity with contradicting attributes)
                entity_extractor = rule.get("entity_extractor")
                attribute_extractor = rule.get("attribute_extractor")
                
                if not entity_extractor or not attribute_extractor:
                    continue
                
                # In a real implementation, we would use advanced NLP to extract entities and attributes
                # For now, use simple regex-based placeholders
                
                # Extract entities from both statements
                entities1 = re.findall(entity_extractor, s1_norm)
                entities2 = re.findall(entity_extractor, s2_norm)
                
                # Find common entities
                common_entities = set(entities1).intersection(set(entities2))
                
                if common_entities:
                    for entity in common_entities:
                        # Extract attributes for this entity from both statements
                        attr_pattern = attribute_extractor.replace("{entity}", re.escape(entity))
                        attrs1 = re.findall(attr_pattern, s1_norm)
                        attrs2 = re.findall(attr_pattern, s2_norm)
                        
                        # Check for contradicting attributes
                        if attrs1 and attrs2 and attrs1[0] != attrs2[0]:
                            return {
                                "is_contradiction": True,
                                "confidence": rule.get("confidence", 0.8),
                                "reason": f"Entity '{entity}' has contradicting attributes",
                                "severity": rule.get("severity", "high")
                            }
        
        # No contradiction found
        return {
            "is_contradiction": False,
            "confidence": 0.6,
            "reason": "No rule-based contradiction detected",
            "severity": "none"
        }
    
    def _run_nli_pair(self, statement1: str, statement2: str) -> Dict[str, Any]:
        """
        Run NLI model to determine if two statements contradict each other.
        
        This is a placeholder method. In a real implementation, this would use an actual NLI model.
        
        Args:
            statement1: First statement
            statement2: Second statement
            
        Returns:
            Dictionary with NLI prediction results
        """
        # This is a simplified placeholder implementation
        if self.nli_model:
            # In a real implementation, run the NLI model here
            # For now, return a default neutral result
            return {
                "label": "neutral",
                "score": 0.5
            }
        
        # Simple keyword-based detection as fallback
        statement1_lower = statement1.lower()
        statement2_lower = statement2.lower()
        
        # Look for direct contradictions
        negation_words = ["not", "no", "never", "isn't", "aren't", "wasn't", "weren't", "doesn't", "don't", "didn't"]
        
        # Extract significant nouns/entities (simplified approach)
        words1 = set(re.findall(r'\b[a-zA-Z]{4,}\b', statement1_lower))
        words2 = set(re.findall(r'\b[a-zA-Z]{4,}\b', statement2_lower))
        
        # Find common significant words
        common_words = words1.intersection(words2)
        
        # If no common words, likely not contradicting
        if not common_words:
            return {
                "label": "neutral",
                "score": 0.7
            }
        
        # Check for presence of negation in one statement but not the other
        has_negation1 = any(neg in statement1_lower for neg in negation_words)
        has_negation2 = any(neg in statement2_lower for neg in negation_words)
        
        if has_negation1 != has_negation2:
            # One has negation, the other doesn't - potential contradiction
            return {
                "label": "contradiction",
                "score": 0.7
            }
        
        # Check for quantity/directional contradictions
        quantity_pairs = [
            ("all", "none"), ("all", "some"), ("always", "never"), 
            ("everyone", "no one"), ("up", "down"), ("left", "right"),
            ("increase", "decrease"), ("more", "less"), ("larger", "smaller")
        ]
        
        for word1, word2 in quantity_pairs:
            if ((word1 in statement1_lower and word2 in statement2_lower) or 
                (word1 in statement2_lower and word2 in statement1_lower)):
                return {
                    "label": "contradiction",
                    "score": 0.8
                }
        
        # Default to neutral
        return {
            "label": "neutral",
            "score": 0.6
        }
    
    def _construct_contradiction_prompt(self, statement1: str, statement2: str) -> str:
        """
        Construct a prompt for LLM-based contradiction detection.
        
        Args:
            statement1: First statement
            statement2: Second statement
            
        Returns:
            Formatted prompt for the LLM
        """
        prompt = "Analyze whether the following two statements contradict each other:\n\n"
        prompt += f"Statement 1: \"{statement1}\"\n"
        prompt += f"Statement 2: \"{statement2}\"\n\n"
        prompt += "Do these statements contradict each other? Provide:\n"
        prompt += "1. A yes/no answer\n"
        prompt += "2. A confidence score (0.0-1.0)\n"
        prompt += "3. A reason for your assessment\n"
        
        return prompt
    
    def _get_default_contradiction_rules(self) -> List[Dict[str, Any]]:
        """
        Get default contradiction detection rules.
        
        Returns:
            List of rule dictionaries
        """
        return [
            # Boolean contradictions
            {
                "type": "keyword",
                "keywords1": ["is", "are", "was", "were"],
                "keywords2": ["is not", "are not", "was not", "were not", "isn't", "aren't", "wasn't", "weren't"],
                "confidence": 0.8,
                "reason": "Positive/negative statement contradiction",
                "severity": "high"
            },
            # Quantifier contradictions
            {
                "type": "keyword",
                "keywords1": ["all", "every", "always", "everyone", "everybody"],
                "keywords2": ["none", "no", "never", "no one", "nobody"],
                "confidence": 0.85,
                "reason": "Universal/negative quantifier contradiction",
                "severity": "high"
            },
            {
                "type": "keyword",
                "keywords1": ["all", "every", "always"],
                "keywords2": ["some", "sometimes", "occasionally", "rarely"],
                "confidence": 0.75,
                "reason": "Universal/particular quantifier potential contradiction",
                "severity": "medium"
            },
            # Directional contradictions
            {
                "type": "keyword",
                "keywords1": ["up", "above", "higher", "increase", "increasing", "grew", "more"],
                "keywords2": ["down", "below", "lower", "decrease", "decreasing", "declined", "less"],
                "confidence": 0.8,
                "reason": "Opposite direction/trend contradiction",
                "severity": "medium"
            },
            # Temporal contradictions
            {
                "type": "keyword",
                "keywords1": ["before", "earlier", "first", "initially", "previously"],
                "keywords2": ["after", "later", "last", "subsequently", "next"],
                "confidence": 0.75,
                "reason": "Temporal sequence contradiction",
                "severity": "medium"
            },
            # Numeric contradictions (regex-based for more precise matching)
            {
                "type": "regex",
                "pattern1": r"(exactly|precisely|only|just) (\d+)",
                "pattern2": r"(exactly|precisely|only|just) (?!\2)(\d+)",
                "confidence": 0.9,
                "reason": "Precise numeric contradiction",
                "severity": "high"
            },
            # Entity-attribute contradictions
            {
                "type": "entity",
                "entity_extractor": r"\b([A-Z][a-z]+(?:\s[A-Z][a-z]+)*)\b",  # Simplified NER
                "attribute_extractor": r"{entity} (?:is|was|has) ([^.,;]+)",
                "confidence": 0.85,
                "reason": "Entity attribute contradiction",
                "severity": "high"
            }
        ]
    
    def _generate_explanation(self, hallucinations: List[Dict[str, Any]]) -> str:
        """
        Generate a human-readable explanation of detection results.
        
        Args:
            hallucinations: List of detected hallucinations
            
        Returns:
            A formatted explanation string
        """
        if not hallucinations:
            return "No internal contradictions detected in the generated text."
        
        # Count unique contradictions (each pair counts as one)
        unique_contradictions = {}
        for h in hallucinations:
            # Use span as the key to group related hallucinations
            span = h["span"]
            
            if h.get("contradiction_pair"):
                if span not in unique_contradictions:
                    unique_contradictions[span] = h
        
        num_contradictions = len(unique_contradictions)
        explanation = f"Detected {num_contradictions} internal contradiction{'s' if num_contradictions != 1 else ''}:\n"
        
        # Include only one side of each contradiction pair
        included_spans = set()
        count = 1
        
        for h in hallucinations:
            if h["span"] not in included_spans:
                explanation += f"{count}. \"{h['text']}\" - {h['reason']} "
                explanation += f"(Severity: {h['severity']}, Confidence: {h['confidence']:.2f})\n"
                included_spans.add(h["span"])
                count += 1
        
        return explanation.strip()
    
    def __repr__(self) -> str:
        """Return a string representation of the detector."""
        return f"ContradictionDetector(method={self.method})" 